\chapter{Ленивая перестройка}
\label{ch:8}

В оставшихся четырех главах мы описываем общие методы проектирования
функциональных структур данных.  Первый из них, рассматриваемый в этой
главе~--- \term{ленивая перестройка}{lazy rebuilding}, разновидность
\term{глобальной перестройки}{global rebuilding} \cite{Overmars1983}.

\section{Порционная перестройка}

Во многих структурах данных соблюдаются инварианты баланса, благодаря
которым гарантируется эффективный доступ. Каноническим примером могут
служить сбалансированные деревья поиска, улучшающие время работы в
худшем случае для многих операций с $O(n)$ у несбалансированных
деревьев до $O(\log n)$. Один из подходов к соблюдению инварианта
баланса~--- перебалансировка структуры после каждой её
модификации. Для большинства сбалансированных структур существует
понятие \term{идеального баланса}{perfect balance}, то есть,
конфигурация, минимизирующая стоимость последующих операций. Однако,
поскольку, как правило, восстанавливать идеальный баланс после
каждого изменения оказывается слишком дорого, в большинстве реализаций
считается достаточным поддерживать некоторое приближение к нему,
ухудшающее показатели не более чем на константный множитель. Примерами
такого подхода являются AVL-деревья \cite{AdelsonVelskiiLandis1962}
и красно-черные деревья \cite{GuibasSedgewick1978}.

Однако если каждое отдельное обновление не слишком сильно влияет на
баланс, привлекательным альтернативным подходом будет отложить
перестройку, пока не пройдет некоторая серия операций, а затем
перебалансировать всю структуру и восстановить идеальный
баланс. Назовем этот подход \term{порционной перестройкой}{batched
  rebuilding}. Порционная перестройка дает хорошие амортизированные
ограничения, если выполняются два условия: (1) глобальная структура
перестраивается не слишком часто, и (2) отдельные модифицирующие
действия ухудшают показатели последующих операций не слишком
сильно. Выражаясь более точно, условие (1) говорит, что, если мы
надеемся достичь амортизированного показателя $O(f(n))$ на операцию, а
преобразование перебалансировки занимает время $O(g(n))$, запускать
это преобразование нельзя чаще, чем раз в $c \cdot g(n) / f(n)$
операций, для некоторой константы $c$. Рассмотрим, например, двоичные
деревья поиска. Перестройка дерева с полной балансировкой занимает
время $O(n)$, так что, если мы хотим, чтобы наши операции занимали
амортизированное время не больше $O(n)$, структуру данных нельзя
перестраивать чаще, чем раз в $c \cdot n / \log n$ операций, для
некоторой константы $c$.

Допустим, что структура данных будет перестраиваться раз в $c \cdot
g(n) / f(n)$ операций, и что отдельная операция над перестроенной
структурой отнимает время $O(f(n))$ (ограничение может быть жёстким
или амортизированным). В этом случае условие (2) утверждает, что,
сделав не более $c \cdot g(n) / f(n)$ обновлений непосредственно после
перестройки, мы по-прежнему будем тратить время не более
$O(f(n))$. Другими словами, стоимость каждой отдельной операции должна
ухудшиться максимум на константный множитель. Функции обновления,
удовлетворяющие условию (2), называются \term{операциями слабого
  обновления}{weak updates}.

Рассмотрим, например, следующий подход к реализации функции
\lstinline!delete! на двоичных деревьях поиска. Вместо того, чтобы
физически уничтожать указанный узел дерева, оставляем его в дереве с
пометкой <<уничтожено>>. Затем, когда стертыми оказываются половина
узлов, делаем глобальный проход, уничтожая стёртые узлы и
восстанавливая идеальный баланс.  Удовлетворяет ли этот подход нашим
двум условиям, если мы хотим, чтобы уничтожение элемента занимало
амортизированное время $O(\log n)$?

Допустим, дерево содержит $n$ узлов, из которых не более половины
помечено как стёртые. Уничтожение стёртых узлов и восстановление
идеального баланса в дереве занимает время $O(n)$. Мы выполняем это
преобразование раз в $\frac{1}{2}n$ операций уничтожения, так что
условие (1) выполнено. На самом деле, условие (1) позволяет нам
перестраивать структуру даже чаще, раз в $c \cdot n / \log n$
операций.  Наивный алгоритм уничтожения ищет нужный узел и помечает его
как уничтоженный. Это отнимает время $O(\log n)$, даже если половина
узлов уже помечена как стёртые, так что условие (2) выполнено.
Заметим, что даже если половина узлов в дереве помечена, средняя
глубина активного узла больше всего на единицу по сравнению со
случаем, когда они физически уничтожены. Дополнительная глубина
ухудшает стоимость операции всего лишь на аддитивную константу, в то
время как условие (2) позволяет времени каждой операции ухудшаться на
константный множитель. Следовательно, условие (2) позволяет нам
перестраивать нашу структуру данных даже ещё реже.

При этом обсуждении мы говорили только об уничтожении
узлов. Разумеется, как правило, в двоичных деревьях поддерживается
также операция вставки элемента.  К сожалению, вставка не является
слабым обновлением, поскольку вставками можно очень быстро создать
длинную цепочку вершин.  Возможен, однако, гибридный подход, когда при
каждой вставке мы проводим локальную перебалансировку, как в
AVL или красно-чёрных деревьях, а уничтожение элемента обрабатывается
методом порционной перестройки.

\begin{exercise}\label{ex:8.1}
  Добавьте к красно-черным деревьям из Раздела~\ref{sc:3.3} функцию
  \lstinline!delete! на основе описанного здесь подхода. Добавьте к
  конструктору \lstinline!T! булевское поле, и поддерживайте
  счётчики-оценки числа
  активных и неактивных элементов в дереве. Для этих счётчиков
  предполагайте, что каждая вставка создает новый элемент, а каждая
  операция уничтожения делает какой-то активный элемент
  неактивным. Обновляйте значение этих счётчиков при перестройке.  Для
  перестройки воспользуйтесь решением Упражнения~\ref{ex:3.9}.
\end{exercise}

В качестве второго примера порционной перестройки рассмотрим
порционные очереди из Раздела~\ref{sc:5.2}. Преобразование перестройки
переносит обращённый хвостовой список в головной, и очередь переходит
в идеально сбалансированное состояние, когда все элементы содержатся в
головном списке.  Как мы уже видели, порционные очереди имеют хорошие
показатели эффективности, но только при эфемерном использовании. Если
их использовать как устойчивую структуру, амортизированные ограничения
ухудшаются до стоимости операции перестройки, поскольку эта операция
может срабатывать сколь угодно часто. Это наблюдение верно для всех
структур с порционной перестройкой.

\section{Глобальная перестройка}
\label{sc:8.2}

Овермарс \cite{Overmars183} описывает метод уничтожения амортизации,
основанный на порционной перестройке. Он называет этот метод
\term{глобальная перестройка}{global rebuilding}. Основная идея
состоит в том, чтобы проводить трансформацию перестройки постепенно,
проводя по несколько шагов при каждой нормальной операции. Полезно
рассматривать это как выполнение преобразования в
сопрограмме. Сложность в том, чтобы запустить сопрограмму достаточно
рано, чтобы она завершилась ко времени, когда понадобится
перестроенная структура.

Более конкретно, при глобальной перестройке поддерживается две копии
каждого объекта. Первичная, или \term{рабочая копия}{working}~--- это
исходная структура. Вторичная копия~--- та, которая постепенно
перестраивается. Все запросы и операции обновления обращаются к рабочей
копии. Когда построение вторичной копии завершено, она становится
новой рабочей копией, а старая уничтожается. При этом либо сразу же
запускается новая вторичная копия, либо некоторое время объект может
работать без вторичной структуры, прежде чем начнется новая фаза
перестройки.

Отдельную сложность представляет обработка обновлений, происходящих,
пока ведется перестройка вторичной копии. Рабочая копия обновляется
обычным образом, но должна быть обновлена и вторичная копия, иначе,
когда она станет рабочей, эффект обновления будет потерян. Однако в
общем случае вторичная копия представлена не в такой форме, которую
можно эффективно обновитью Таким образом, обновления вторичной копии
буферизуются и выполняются, по несколько за раз, после того, как
вторичная копия перестроена, но до того, как она становится рабочей.

Глобальную перестройку можно реализовать в чисто функциональном стиле,
и несколько таких реализаций существуют. Например, очереди реального
времени Худа и Мелвилла \cite{HoodMelville1981} основаны именно на
этом методе. В отличие от порционной перестройки, при глобальной
перестройке не возникает проблем с устойчивостью. Поскольку ни одна из
операций не является особенно дорогой, произвольное повторение
операций не влияет на временные характеристики.  К сожалению, часто
глобальная перестройка дает очень сложные структуры. В частности,
представление вторичной копии, которое сводится к хранению
промежуточного состояния сопрограммы, может быть довольно неприятным.

\section{Пример: очереди реального времени по Худу-Мелвиллу}
\label{sc:8.2.1}

Реализация очередей реального времени Худа и Мелвилла
\cite{HoodMelville1981} во многом похожа на очереди реального времени
из Раздела~\cite{sc:7.2}. В обеих реализациях поддерживается два
списка, представляющие головную и хвостовую части очереди
соответственно, и ведется пошаговый процесс переноса элементов из
хвостового списка в головной, начиная с того момента, когда хвостовой
список становится на единицу длиннее, чем головной.  Разница состоит в
деталях этого пошагового проворота.

Рассмотрим сначала, как можно провести пошаговое обращение списка
путем хранения двух списков и постепенного переноса элементов из
одного в другой.
\begin{lstlisting}
  datatype $\alpha$ ReverseState = Working of $\alpha$ list $\times$ $\alpha$ list | Done of $\alpha$ list
  
  fun startReverse xs = Working (xs, [])

  fun exec (Working (x :: xs, xs')) = Working (xs, x :: xs')
    | exec (Working ([], xs')) = Done xs'
\end{lstlisting}
Чтобы обратить список \lstinline!xs!, мы сначала создаем новое
состояние \lstinline!Working (xs, [])!, а затем многократно вызываем
\lstinline!exec!, пока не получим состояние \lstinline!Done! с
обращенным списком. Всего требуется $n + 1$ вызовов \lstinline!exec!,
где $n$~--- длина исходного списка \lstinline!xs!.

Можно провести пошаговую конкатенацию двух списков, применив этот
прием дважды. Сначала мы обращаем \lstinline!xs!, получая
\lstinline!xs'!, а затем обращаем \lstinline!xs'!, добавляя его к
\lstinline!ys!.
\begin{lstlisting}
  datatype $\alpha$ AppendState =
         Reversing of $\alpha$ list $\times$ list $\times$ $\alpha$ list $\times$ $\alpha$ list
       | Appending of $\alpha$ list $\times$ $\alpha$ list
       | Done of $\alpha$ list

  fun startAppend (xs, ys) = Reversing (xs, [], ys)

  fun exec (Reversing (x :: xs, xs', ys)) = Reversing (xs, x :: xs', ys)
    | exec (Reversing ([], xs', ys)) = Appending (xs', ys)
    | exec (Appending (x :: xs', ys)) = Appending (xs', x :: ys)
    | exec (Appending ([], ys)) = Done ys
\end{lstlisting}
Всего требуется $2m + 2$ вызова \lstinline!exec!, если длина исходного
списка \lstinline!xs! равна $m$.

Наконец, чтобы добавить \lstinline!f! к обращенному \lstinline!r!, мы
проводим три обращения. Сначала мы в параллель обращаем \lstinline!f!
и \lstinline!r!, получая \lstinline!f'! и \lstinline!r'!, а затем
приписываем обращенный \lstinline!f'! к \lstinline!r'!. Нижеследующий
код предполагает, что длина \lstinline!r! на единицу больше
\lstinline!f!.
\begin{lstlisting}
  datatype $\alpha$ RotationState =
         Reversing of $\alpha$ list $\times$ $\alpha$ list $\times$ $\alpha$ list $\times$ $\alpha$ list
       | Appending of $\alpha$ list $\times$ $\alpha$ list
       | Done of $\alpha$ list

  fun startRotation (f, r) = Reversing (f, [], r, [])

  fun exec (Reversing (x :: f, f', y :: r, r')) = Reversing (f, x :: f', r, y :: r')
    | exec (Reversing ([], f', [y], r')) = Appending (f', y :: r')
    | exec (Appending (x :: f', r')) = Appending (f', x :: r')
    | exec (Appending ([], r') = Done r'
\end{lstlisting}
Как и раньше, процедура завершается после $2m + 2$ вызовов
\lstinline!exec!, где $m$~--- исходная длина списка \lstinline!f!.

К сожалению, у этого способа проворота есть большой недостаток. Если
мы просто зовем \lstinline!exec! по несколько раз
при каждом вызове \lstinline!snoc! или \lstinline!tail!, то ко
времени, когда поворот закончится, ответ может быть уже не тот,
который нам нужен! В частности, если за время поворота было $k$
вызовов \lstinline!tail!, то $k$ первых элементов получившегося списка
уже не актуальны. Эту проблему можно решить двумя основными
способами. Во-первых, можно хранить счетчик устаревших элементов, и
добавить к процедуре поворота третье состояние \lstinline!Deleting!,
которое уничтожает элементы по несколько за раз, пока устаревшие
элементы не кончатся. Этот подход точнее всего соответствует
определению глобальной перестройки. Однако еще лучше просто не
включать устаревшие элементы в окончательный список. Мы отслеживаем,
сколько живых элементов осталось в \lstinline!f'!, и перестаем
копировать элементы из \lstinline!f'! в \lstinline!r'!, когда счетчик
достигает нуля. Каждый вызов \lstinline!tail! во время поворота
уменьшает число живых элементов.
\begin{lstlisting}
  datatype $\alpha$ RotationState =
         Reversing of int $\times$ $\alpha$ list $\times$ $\alpha$ list $\times$ $\alpha$ list $\times$ $\alpha$ list
       | Appending of int $\times$ $\alpha$ list $\times$ $\alpha$ list
       | Done of $\alpha$ list

  fun startRotation (f, r) = Reversing (0, f, [], r, [])
  
  fun exec (Reversing (ok, x :: f, f', y :: r, r')) =
        Reversing (ok+1, f, x :: f', r, y :: r')
    | exec (Reversing (ok, [], f', [y], r')) = Appending (ok, f', y :: r')
    | exec (Appending (0, f', r')) = Done r'
    | exec (Appending (ok, x :: f', r')) = Appending (ok-1, f', x ::
    r')

  fun invalidate (Reversing (ok, f, f', r, r')) = Reversing (ok-1, f, f', r, r')
    | invalidate (Appending (0, f', x :: r')) = Done r'
    | invalidate (Appending (ok, f', r')) = Appending (ok-1, f', r')
\end{lstlisting}
Этот процесс завершается после $2m + 2$ вызовов к \lstinline!exec! или
\lstinline!invalidate!, где $m$~--- исходная длина \lstinline!f!.

Требуется рассмотреть ещё три нетривиальных мелких вопроса. Во-первых,
во время поворота несколько первых элементов очереди оказываются в
конце поля \lstinline!f'! структуры-состояния поворота. Как нам при
этом отвечать на запрос \lstinline!head!? Решение этой дилеммы состоит
в том, чтобы хранить рабочую копию старого головного списка. Нужно
только добиться того, чтобы новая копия головного списка оказалась
готова к тому времени, как исчерпается старая. Во время поворота поле
\lstinline!lenf! измеряет длину создаваемого списка, а не рабочей
копии \lstinline!f!. Однако между поворотами поле \lstinline!lenf!
содержит длину \lstinline!f!.

Во-вторых, надо решить, сколько именно обращений к \lstinline!exec!
надо делать при каждом вызове \lstinline!snoc! и \lstinline!tail!,
чтобы гарантировать, что поворот закончится к тому времени, когда либо
нужно будет начать следующий поворот, либо будет израсходована рабочая
копия головного списка.  Допустим, что в начале поворота длина списка
\lstinline!f! равна $m$, а длина списка \lstinline!r! равна
$m+1$. Тогда следующий поворот начнется после $2m+2$ вставок или
извлечений (в любом соотношении), однако рабочая копия головного
списка окажется израсходованной уже через $m$ извлечений. Всего
поворот заканчивается через $2m+2$ шагов. Если при каждой операции мы
зовем \lstinline!exec! два раза, включая операцию, которая запускает
поворот, то поворот завершится самое большее через $m$ операций после
своего начала.

В-третьих, поскольку каждый поворот заканчивается задолго до того, как
начинается следующий, требуется добавить к типу
\lstinline!RotationState! состояние \lstinline!Idle! (неактивное), так
что \lstinline!exec Idle = Idle!. После этого мы можем спокойно звать
\lstinline!exec!, не заботясь о том, находимся мы в процессе поворота
или нет.

Оставшиеся детали должны уже быть знакомы читателю. Полная реализация
приведена на Рис.~\ref{fig:8.1}.

\begin{figure}
  \centering
  
  \caption{Очереди реального времени на основе глобальной перестройки.}
  \label{fig:8.1}
\end{figure}

\begin{exercise}\label{ex:8.1}
  Докажите, что если звать \lstinline!exec! дважды при начале
  каждого поворота и один раз при каждой вставке или извлечении
  элемента, этого будет достаточно, чтобы поворот завершался
  вовремя. Соответствующим образом измените код.
\end{exercise}

\begin{exercise}\label{ex:8.2}
  Замените поля \lstinline!lenf! и \lstinline!lenr! одним полем
  \lstinline!diff!, которое хранит разницу между длинами списков
  \lstinline!f! и \lstinline!r!. Поле \lstinline!diff! не обязательно
  должно хранить точное значение в процессе поворота, но к его концу
  должно быть точным.
\end{exercise}

\section{Ленивая перестройка}
\label{sc:8.3x}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "pfds"
%%% End: 
