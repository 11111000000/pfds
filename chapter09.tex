\chapter{Числовые представления}
\label{ch:9}

Рассмотрим обыкновенные представления списков и натуральных чисел, а
также несколько типичных функций над этими типами данных.
\begin{lstlisting}
  datatype $\alpha$ List =                   datatype Nat =
       Nil                                Zero
     | Cons of $\alpha$ $\times$ $\alpha$ List                  | Succ of Nat

  fun tail (Cons (x, xs)) = xs       fun pred (Succ n) = n

  fun append (Nil, ys) = ys          fun plus (Zero, n) = n
    | append (Cons (x, xs), ys) =      | plus (Succ m, n) =
       Cons (x, append (xs, ys))          Succ (plus (m, n))
\end{lstlisting}
Помимо того, что списки содержат элементы, а натуральные числа нет,
эти две реализации практически совпадают. Подобным же образом
соотносятся биномиальные кучи и двоичные числа. Эти примеры наводят на
сильную аналогию между представлениями числа $n$ и представлениями
объектов-контейнеров размером $n$. Функции, работающие с контейнерами,
сильно напоминают арифметические функции, работающие с
числами. Например, добавление нового элемента напоминает увеличение
числа на единицу, удаление элемента напоминает уменьшение числа на
единицу, а слияние двух контейнеров напоминает сложение двух
чисел. Можно использовать эту аналогию для проектирования новых
представлений абстракций контейнеров~--- достаточно выбрать
представление натуральных чисел, обладающее заданными свойствами и
соответствующим образом определить функции над
объектами-контейнерами. Назовем реализацию, спроектированную таким
образом, \term{числовым представлением}{numerical representation}.

В этой главе мы исследуем несколько числовых представлений для двух
различных абстракций: \term{кучи}{heaps} и \term{списков со свободным
  доступом}{random-access lists} (известных также как \term{гибкие массивы}{flexible
arrays}). Эти две абстракции подчеркивают различные наборы
арифметических операций. Для куч требуются эффективные функции
увеличения на единицу и сложения, а для списков со свободным доступом
требуются эффективные функции увеличения и уменьшения на единицу.

\section{Позиционные системы счисления}
\label{sc:9.1}

\term{Позиционная система счисления}{positional number system}
\cite{Knuth1973b}~--- способ записи числа в виде последовательности
цифр $b_0\ldots b_{m-1}$. Цифра $b_0$ называется \term{младшим разрядом}{least
  significant digit}, а цифра $b_{m-1}$ \term{старшим разрядом}{most
  significant digit}. Кроме обычных десятичных чисел, мы всегда будем
записывать последовательности цифр в порядке от младшего разряда к старшему.

Каждый разряд $b_i$ имеет вес $w_i$, так что значение
последовательности $b_0\ldots b_{m-1}$ равно $\sum_{i=0}^{m-1}
b_iw_i$. Для каждой конкретной позиционной системы счисления
последовательность весов фиксирована, и фиксирован набор цифр $D_i$,
из которых выбирается каждая $b_i$. Для единичных чисел $w_i = 1$ и
$D_i = \{\mathtt{1}\}$ для всех $i$, а для двоичных чисел $w_i = 2^i$,
а $D_i = \{\mathtt{0}, \mathtt{1}\}$. (Мы принимаем соглашение, по
которому все цифры, кроме обычных десятичных, пишутся шрифтом пишущей
машинки.) Говорится, что число записано по основанию $B$, если $w_i =
B^i$, а $D_i = \{\mathtt{0}, \ldots, B-1\}$. Чаще всего, но не всегда,
веса разрядов представляют собой увеличивающуюся степенную
последовательность, а множество $D_i$ во всех разрядах одинаково.

Система счисления называется \term{избыточной}{redundant}, если
некоторые числа могут быть представлены более, чем одним способом.
Например, можно получить избыточную систему двоичного счисления, взяв
$w_i = 2^i$ и $D_i = \{\mathtt{0}, \mathtt{1}, \mathtt{2}\}$. Тогда
десятичное число 13 можно будет записать как \texttt{1011},
\texttt{1201} или \texttt{122}. Мы запрещаем нули в конце числа,
поскольку иначе почти все системы счисления будут тривиально
избыточны.

Компьютерные представления позиционных систем счисления могут быть
\term{плотными}{dense} или \term{неплотными}{sparse}. Плотное
представление~--- это просто список (или какая-то друга
последовательность) цифр, включая нули. Напротив, при неплотном
представлении нули пропускаются. В таком случае, требуется хранить
информацию либо о ранге (т.~е., индексе), либо о весе каждой ненулевой
цифры.  На Рис.~\ref{fig:9.1} показаны два разных представления
двоичных чисел в Стандартном ML, одно из которых плотное, второе
неплотное, а также функции увеличения на единицу, уменьшения на
единицу и сложения для каждого из них. Среди уже виденных нами
числовых представлений биномиальные кучи с расписаниями
(Раздел~\ref{sc:7.3}) используют плотное представление, а биномиальные
кучи (Раздел~\ref{sc:3.2}) и ленивые биномиальные кучи
(Раздел~\ref{sc:6.4.1})~--- неплотное представление.

\begin{figure}
  \centering
  
  \mbox{возрастающий порядок по старшинству}\\
  \mbox{перенос}\\
  \mbox{занятие}\\ -- !!!!! термин?
  \mbox{перенос}\\
  \mbox{возрастающий порядок весов, каждый из которых степень двойки}\\

  \caption{Два представления двоичных чисел.}
  \label{fig:9.1}
\end{figure}

\section{Двоичные числа}
\label{sc:9.2}

Имея позиционную систему счисления, мы можем реализовать числовое
представление на её основе в виде последовательности
деревьев. Количество и размеры деревьев, представляющих коллекцию
размера $n$, определяются положением $n$ в позиционной системе
счисления. Для каждого веса $w_i$ имеются $b_i$ деревьев
соответствующего размера. Например, двоичное представление числа 73
выглядит как \texttt{1001001}, так что коллекция размера 73 в двоичном
числовом представлении будет содержать три дерева размеров 1, 8 и 64.

Как правило, деревья в числовых представлениях обладают весьма
регулярной структурой. Например, в двоичных числовых представлениях
все деревья имеют размер-степень двойки. Три часто встречающихся типа
деревьев с такой структурой~--- \term{полные двоичные листовые
  деревья}{complete binary leaf trees} \cite{KaldewaijDielissen1996}, \term{биномиальные
  деревья}{binomial trees} \cite{Vuillemin1978} и
\term{пеннанты}{pennants} \cite{SackStrothotte1990}.
%% !!!!! Посмотреть, как переводится pennant !!!!!

\begin{definition}
  \textbf{(Полные двоичные листовые деревья)} Полное двоичное листовое
  дерево ранга 0~--- это лист; полное двоичное листовое дерево ранга
  $r > 0$ представляет собой узел с двумя поддеревьями, каждое из
  которых является полным двоичным листовым деревом ранга $r -
  1$. Листовое дерево~--- это дерево, хранящее элементы только в
  листовых узлах, в отличие от обычных деревьев, где элементы
  содержатся в каждом узле. Полное двоичное дерево ранга $r$ содержит
  $2^{r+1} - 1$ узлов, но только $2^r$ листьев. Следовательно, полное
  двоичное листовое дерево ранга $r$ содержит $2^r$ элементов.
\end{definition}

\begin{definition}
  \textbf{(Биномиальные деревья)} Биномальное дерево ранга $r$
  представляет собой узел с $r$ дочерними деревьями $c_1 \ldots c_r$,
  где каждое $c_i$ является биномиальным деревом ранга $r -
  i$. Можно также определить биномиальное дерево ранга $r > 0$ как
  биномиальное дерево ранга $r - 1$, к которому в качестве самого
  левого поддерева добавлено другое биномальное дерево ранга $r -
  1$. Из второго определения легко видеть, что биномиальное дерево
  ранга $r$ содержит $2^r$ узлов.
\end{definition}

\begin{definition}
  \textbf{(Пеннанты)} Пеннант ранга 0 представляет собой один узел, а
  пеннант ранга $r > 0$ представляет собой узел с единственным
  поддеревом~--- полным двоичным деревом ранга $r - 1$. Полное
  двоичное дерево содержит $2^r - 1$ элементов, так что пеннант
  содержит $2^r$ элементов.
\end{definition}

\begin{figure}
  \centering
  
  \caption{Три дерева ранга 3: (a) полное двоичное листовое дерево, (b) биномиальное дерево и (c) пеннант.}
  \label{fig:9.2}
\end{figure}

Три этих разновидности деревьев показаны на
Рис.~\ref{fig:9.2}. Выбор разновидности для каждой структуры данных
зависит от свойств, которыми эта структура должна обладать, например,
от порядка, в котором требуется хранить элементы в деревьях. Важным
вопросом при оценке соответствия разновидности деревьев для конкретной
структуры данных будет то, насколько хорошо данная разновидность
поддерживает функции, аналогичные переносу и занятию в двоичной
арифметике. При имитации переноса мы \term{связываем}{link} два дерева
ранга $r$ и получаем дерево ранга $r+1$. Аналогично, при имитации
занятия мы \term{развязываем}{unlink} дерево ранга $r > 0$ и получаем
два дерева ранга $r-1$. На Рис.~\ref{fig:9.3} показана операция
связывания (обозначенная $\circ$) %% !!!!! Найти символ в TeX !!!!!
для каждой из трех разновидностей деревьев. Если мы предполагаем, что
элементы не переупорядочиваются, любая из разновидностей может быть
связана или развязана за время $O(1)$.

\begin{figure}
  \centering
  
  \caption{Связывание двух деревьев ранга $r$ в дерево ранга $r+1$ для (a) полных двоичных листовых деревьев, (b) биномиальных деревьев и (c) пеннантов.}
  \label{fig:9.3}
\end{figure}

В предыдущих главах мы уже видели несколько разновидностей куч,
основанных на двоичной арифметике и биномиальных деревьях. Теперь мы
сначала рассмотрим простое числовое представление для списков с
произвольным доступом. Затем мы исследуем насколько вариаций двоичной
арифметики, позволяющих улучшить асимптотические показатели.

\subsection{Двоичные списки с произвольным доступом}
\label{sc:9.2.1}

\term{Список с произвольным доступом}{random access list}, называемый
также односторонним гибким массивом~--- это структура данных,
поддерживающая, подобно массиву, функции доступа и модификации любого
элемента, а также обыкновенные функции для списков: \lstinline!cons!,
\lstinline!head! и \lstinline!tail!. Сигнатура списков с произвольным
доступом приведена на Рис.~\ref{fig:9.4}.

\begin{figure}
  \centering
  
  \caption{Сигнатура списков с произвольным доступом.}
  \label{fig:9.4}
\end{figure}

Мы реализуем списки с произвольным доступом, используя двоичное
числовое представление. Двоичный список с произвольным доступом
размера $n$ содержит по дереву на каждую единицу в двоичном
представлении $n$. Ранг каждого дерева соответствует рангу
соответствующей цифры; если $i$-й бит $n$ равен единице, то список с
произвольным доступом содержит дерево размера $2^i$. Мы можем
использовать любую из трех разновидностей деревьев и либо плотное,
либо неплотное представление. Для этого примера мы используем
простейшее сочетание: полные двоичные листовые деревья и плотное
представление. Таким образом, тип \lstinline!RList! выглядит так:
\begin{lstlisting}
  datatype $\alpha$ Tree = Leaf of $\alpha$ | Node of int $\times$ $\alpha$ Tree $\times$ $\alpha$ Tree
  datatype $\alpha$ Digit = Zero | One of $\alpha$ Tree
  datatype $\alpha$ RList = $\alpha$ Digit list
\end{lstlisting}
Целое число в каждой вершине~--- это размер дерева. Это число
избыточно, поскольку размер каждого дерева полностью определяется
размером его родителя или позицией в списке цифр, но мы все равно его
храним ради удобства. Деревья хранятся в порядке возрастания размера,
а порядок элементов~--- слева направо, как внутри, так и между
деревьями. Таким образом, головой списка с произвольным доступом
является самый левый лист наименьшего дерева. На Рис.~\ref{fig:9.5}
показан двоичный список с произвольным доступом размера 7. Заметим,
что максимальное число деревьев в списке размера $n$ равно 
$\lfloor \log (n+1) \rfloor$, а максимальная глубина дерева равна 
$\lfloor \log n \rfloor$.

\begin{figure}
  \centering
  
  \caption{Двоичный список с произвольным доступом, содержащий элементы 0\ldots 6.}
  \label{fig:9.5}
\end{figure}

Вставка элемента в двоичный список с произвольным доступом (при помощи
\lstinline!cons!) аналогична увеличению двоичного числа на
единицу. Напомним функцию увеличения для двоичных чисел:
\begin{lstlisting}
  fun inc [] = [One]
    | inc (Zero :: ds) = One :: ds
    | inc (One :: ds) = Zero :: inc ds
\end{lstlisting}
Чтобы добавить новый элемент к началу списка, мы сначала преобразуем
его в лист, а затем вставляем его в список деревьев с помощью
вспомогательной функции \lstinline!consTree!, которая следует образцу
\lstinline!inc!.
\begin{lstlisting}
  fun cons (x, ts) = consTree (Leaf x, ts)

  fun consTree (t, []) = [One t]
    | consTree (t, Zero :: ts) = One t :: ts
    | consTree (t$_1$, One t$_2$ :: ts) = Zero :: consTree (link (t$_1$, t$_2$), ts)
\end{lstlisting}
Вспомогательная функция \lstinline!link! порождает новое дерево из двух
поддеревьев одинакового размера и автоматически вычисляет его размер.

Уничтожение элемента в двоичном списке с произвольным доступом (при
помощи \lstinline!tail!) аналонично уменьшению двоичного числа на
единицу. Напомним функцию уменьшения для плотных двоичных чисел:
\begin{lstlisting}
  fun dec [One] = []
    | dec (One :: ds) = Zero :: ds
    | dec (Zero :: ds) = One :: dec ds
\end{lstlisting}
Соответствующая функция для списков деревьев называется
\lstinline!unconsTree!. Будучи примененной к дереву, чья первая цифра
имеет ранг $r$, \lstinline!unconsTree! возвращает пару, состоящую из
дерева ранга $r$ и новый список без этого дерева.
\begin{lstlisting}
  fun unconsTree [One t] = (t, [])
    | unconsTree (One t :: ts) = (t, Zero :: ts)
    | unconsTree (Zero :: ts) = 
       let val (Noce (_, t$_1$, t$_2$), ts') = unconsTree ts
       in (t$_1$, One t$_2$ :: ts') end
\end{lstlisting}
Функции \lstinline!head! и \lstinline!tail!  удаляют самый левый
элемент при помощи \lstinline!unconsTree!, а затем, соответственно,
либо возвращают этот элемент, либо отбрасывают.
\begin{lstlisting}
  fun head ts = let val (Leaf x, _) = unconsTree ts in x end
  fun tail ts = let val (_, ts') = unconsTree ts in ts' end
\end{lstlisting}

Функции \lstinline!lookup! и \lstinline!update! не соответствуют
никаким арифметическим операциям. Они просто пользуются организацией
двоичных списков произвольного доступа в виде списков логарифмической
длины, состоящих из деревьев логарифмической глубины. Поиск элемента
состоит из двух этапов. Сначала в списке мы ищем нужное дерево, а
затем в этом дереве ищем требуемый элемент. Вспомогательная функция
\lstinline!lookupTree! использует поле размера в каждом узле, чтобы
определить, находится ли $i$-й элемент в левом или правом
поддереве.
\begin{lstlisting}
  fun lookup (i, Zero :: ts) = lookup (i, ts)
    | lookup (i, One t :: ts) =
       if i < size t then lookupTree (i, t) else lookup (i - size t, ts)

  fun lookupTree (0, Leaf x) = x
    | lookupTree (i, Node (w, t$_1$, t$_2$)) =
       if i < w div 2 then lookupTree (i, t$_1$
       else lookupTree (i - w div 2, t$_2$)
\end{lstlisting}
\lstinline!update! действует аналогично, но вдобавок копирует путь от
корня до обновляемого листа.
\begin{lstlisting}
  fun update (i, y, Zero::ts) = Zero :: update (i, y, ts)
    | update (i, y, One t :: ts) =
       if i < size t then One (updateTree (i, y, t)) :: ts
       else One t :: update (i - size t, y, ts)

  fun updateTree (0, y, Leaf x) = Leaf y
    | updateTree (i, y, Node (w, t$_1$, t$_2$)) =
       if i < w div 2 then Node (w, updateTree (i, y, t$_1$), t$_2$)
       else Node (w, t$_1$, updateTree (i - w div 2, y, t$_2$))
\end{lstlisting}
Полный код этой реализации приведен на Рис.~\ref{fig:9.6}

\begin{figure}
  \centering
  
  \caption{Двоичные списки с произвольным доступом.}
  \label{fig:9.6}
\end{figure}

Функции \lstinline!cons!, \lstinline!head! и \lstinline!tail!
производят не более $O(1)$ работы на цифру, так что общее время их
работы $O(\log n)$ в худшем случае. \lstinline!lookup! и
\lstinline!update! требуют не более $O(\log n)$ времени на поиск
нужного дерева, а затем не более $O(\log n)$ времени на поиск нужного
элемента в этом дереве, так что общее время их работы также $O(\log
n)$ в худшем случае.

\begin{exercise}\label{ex:9.1}
  Напишите функцию \lstinline!drop! типа 
  \lstinline!int $\times$ $\alpha$ RList $\to$ $\alpha$ RList!, уничтожающую первые $k$
  элементов двоичного списка с произвольным доступом. Функция должна
  работать за время $O(\log n)$.
\end{exercise}

\begin{exercise}\label{ex:9.2}
  Напишите функцию \lstinline!create! типа 
  \lstinline!int $\times$ $\alpha$ $\to$ $\alpha$ RList!, которая создает
  двоичный список с произвольным доступом, содержащий $n$ копий
  некоторого значения $x$. Функция также должна работать за время
  $O(\log n)$. (Может оказаться полезным вспомнить Упражнение~\ref{ex:2.5}.)
\end{exercise}

\begin{exercise}\label{ex:9.3}
  Реализуйте \lstinline!BinaryRandomAccessList! заново, используя
  неплотное представление
  \begin{lstlisting}
    datatype $\alpha$ Tree = Leaf of $\alpha$ | Node of int $\times$ $\alpha$ Tree $\times$ $\alpha$ Tree
    type $\alpha$ RList = $\alpha$ Tree list
  \end{lstlisting}
\end{exercise}

\subsection{Безнулевые представления}
\label{sc:9.2.2}

В двоичных списках с произвольным доступом разочаровывает то, что
списковые функции \lstinline!cons!, \lstinline!head! и
\lstinline!tail! требуют $O(\log n)$ времени вместо $O(1)$. В
следующих трех подразделах мы исследуем варианты двоичных чисел,
улучшающие время работы всех трех функций до $O(1)$. В этом подразделе
мы начинаем с функции \lstinline!head!.

\begin{remark}
  Очевидное решение, позволяющее \lstinline!head! выполняться за время
  $O(1)$~--- хранить первый элемент отдельно от остального списка,
  подобно функтору \lstinline!ExplicitMin! из
  Упражнения~\ref{ex:3.7}. Другое решение~--- использовать неплотное
  представление и либо биномиальные деревья, либо пеннанты, так что
  головой списка будет корень первого дерева. Решение, которое мы
  исследуем в этом подразделе, хорошо тем, что оно также немного
  улучшает время работы \lstinline!lookup! и \lstinline!update!.
\end{remark}

Сейчас \lstinline!head! у нас реализована через вызов
\lstinline!unconsTree!, которая выделяет первый элемент, а также
перестраивает список без этого элемента. При таком подходе мы получаем
компактный код, поскольку \lstinline!unconsTree! поддерживает как
\lstinline!head!, так и \lstinline!tail!, но при этом теряется время
на построение списков, которые тут же отбрасываются функцией
\lstinline!head!. Ради большей эффективности имеет смысл реализовать
\lstinline!head! напрямую. В качестве особого случая, легко заставить
\lstinline!head! работать за время $O(1)$, когда первая цифра не ноль.
\begin{lstlisting}
  fun head (One (Leaf x) :: _) = x
\end{lstlisting}
Вдохновленные этим правилом, мы хотели бы устроить так, чтобы первая
цифра \emph{никогда} не была нулем. Есть множество простых трюков,
достигающих именно этого, но более красивым решением будет
использовать \term{безнулевое}{zeroless} представление, где ни одна
цифра не равна нулю.

Безнулевые двоичные числа строятся из единиц и двоек, а не из единиц и
нулей. Вес $i$-й цифры по-прежнему равен $2^i$. Так, например,
десятичное число 16 можно записать как \texttt{2111} вместо
\texttt{00001}. Функция добавления единицы на безнулевых двоичных
числах реализуется так:
\begin{lstlisting}
  datatype Digit = One | Two
  type Nat = Digit list

  fun inc [] = [One]
    | inc (One :: ds) = Two :: ds
    | inc (Two :: ds) = One :: inc ds
\end{lstlisting}

\begin{exercise}\label{ex:9.4}
  Напишите функции уменьшения на единицу и сложения для безнулевых
  двоичных чисел. Заметим, что переноситься при сложении может как
  единица, так и двойка.
\end{exercise}

Теперь если мы заменим тип цифр в двоичных списках с произвольным
доступом на
\begin{lstlisting}
  datatype $\alpha$ Digit = One of $\alpha$ Tree | Two of $\alpha$ Tree $\times$ $\alpha$ Tree
\end{lstlisting}
то можем реализовать \lstinline!head! как
\begin{lstlisting}
  fun head (One (Leaf x) :: _) = x
    | head (Two (Leaf x, Leaf y) :: _) = x
\end{lstlisting}
Ясно, что эта функция работает за время $O(1)$.

\begin{exercise}\label{ex:9.5}
  Реализуйте оставшиеся функции для этого типа.
\end{exercise}

\begin{exercise}\label{ex:9.6}
  Покажите, что теперь функции \lstinline!lookup! и
  \lstinline!update!, примененные к элементу $i$, работают за время
  $O(\log i)$.
\end{exercise}

\begin{exercise}\label{ex:9.7}
  При некоторых дополнительных условиях красно-черные деревья
  (Раздел~\ref{sc:3.3}) можно рассматривать как числовое
  представление. Сопоставьте безнулевые двоичные списки с произвольным
  доступом и красно-черные деревья, в которых вставка разрешена только
  в самую левую позицию. Обратите особое внимание на функции
  \lstinline!cons! и \lstinline!insert!, а также на инварианты формы
  структур, порождаемых этими функциями.
\end{exercise}

\subsection{Ленивые представления}
\label{sc:9.2.3}

Допустим, мы представляем двоичные числа как потоки цифр, а не
списки. Тогда функция увеличения на единицу получает вид
\begin{lstlisting}
  fun lazy inc ($\$$Nil) = $\$$Cons (One, $\$$Nil)
         | inc ($\$$Cons (Zero, ds)) = $\$$Cons (One, ds)
         | inc ($\$$Cons (One, ds)) = $\$$Cons (Zero, inc ds)
\end{lstlisting}
Заметим, что функция эта пошаговая.

В Разделе~\ref{sc:6.4.1} мы видели, как с помощью ленивого вычисления
можно заставить вставку в биномиальные кучи работать за
амортизированное время $O(1)$, так что нас не должно удивлять, что
наша новая версия \lstinline!inc! также работает за амортизированное
время $O(1)$. Мы доказываем это по методу банкира.

\emph{Доказательство.} Пусть каждая цифра ноль несет одну единицу долга, а
цифра единица~--- ноль единиц долга. Допустим, \lstinline!ds!
начинается с $k$ единиц (\lstinline!One!), а затем имеет ноль
(\lstinline!Zero!). Тогда \lstinline!inc ds! заменяет все эти \lstinline!One!
на \lstinline!Zero!, а \lstinline!Zero! на \lstinline!One!. 
Выделим по одной единице долга на каждый
из этих шагов. Теперь у каждого элемента \lstinline!Zero! есть одна
единица долга, а у \lstinline!One! две: одна, унаследованная от
исходной задержки в этом месте, и одна, созданная только
что. Высвобождение этих двух единиц долга восстанавливает
инвариант. Поскольку амортизированная стоимость функции равна ее
нераздельной стоимости (здесь это $O(1)$) плюс число высвобождаемых
единиц долга (здесь две), \lstinline!inc! работает за амортизированное
время $O(1)$.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "pfds"
%%% End: 
 