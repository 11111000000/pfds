\chapter{Неявное рекурсивное замедление}
\label{ch:11}

В Разделе~\ref{sc:9.2.3} мы видели, что избыточное ленивое
представление двоичных чисел может поддерживать как функцию
увеличения, так и уменьшения за амортизированное время $O(1)$. В
Разделе~\ref{sc:10.1.2} мы видели, что гетерогенные типы и полиморфная
рекурсия позволяют строить чрезвычайно простые реализации числовых
представлений, например, двоичных списков с произвольным доступом. В
этой главе мы сочетаем и расширяем эти идеи, получая в результате
методику, называемую \term{неявное рекурсивное замедление}{implicit
  recursive slowdown}.

Каплан и Тарждан \cite{KaplanTarjan1995, KaplanTarjan1996b,
  KaplanTarjan1996a} исследовали родственную методику под названием
\term{рекурсивное замедление}{recursive slowdoen}, основанную, в
отличие от нашей, не на ленивых двоичных числах, а на сегментированных
двоичных числах (Раздел~\ref{sc:9.2.4}). Сходства и различия
реализаций, основанных на рекурсивном замедлении и на неявном
рекурсивном замедлении, в сущности, аналогичны сходствам и различиям
между этими двумя системами счисления.

\section{Очереди и деки}
\label{sc:11.1}

Напомним устройство двоичных списков с произвольным доступом из
Раздела~\ref{sc:10.1.2}, имеющих тип
\begin{lstlisting}
  datatype $\alpha$ RList =
       Nil | Zero of ($\alpha$ $\times$ $\alpha$ RList | One of $\alpha$ $\times$ ($\alpha$ $\times$ $\alpha$) RList
\end{lstlisting}
Чтобы упростить дальнейшее обсуждение, давайте заменим этот тип на
\begin{lstlisting}
  datatype $\alpha$ Digit = Zero | One of $\alpha$
  datatype $\alpha$ RList = Shallow of $\alpha$ Digit | Deep of $\alpha$ Digit $\times$ ($\alpha$ $\times$ $\alpha$) RList
\end{lstlisting}
Мелкий (\lstinline!Shallow!) список содержит от нуля до одного
элемента. Глубокий (\lstinline!Deep!) список содержит ноль или один
элемент, а также список пар. С этим типом мы можем играть во многие из
игр, освоенных нами при рассмотрении двоичных списков с произвольным
доступом в Главе~\ref{ch:9}. Например, можно поддержать функцию
\lstinline!head! за время $O(1)$, переключившись на безнулевое
представление вроде
\begin{lstlisting}
  datatype $\alpha$ Digit = Zero | One of $\alpha$ | Two of $\alpha$ $\times$ $\alpha$
  datatype $\alpha$ RList = Shallow of $\alpha$ Digit | Deep of $\alpha$ Digit $\times$ ($\alpha$ $\times$ $\alpha$) RList
\end{lstlisting}
В этом представлении все цифре в глубоком (\lstinline!Deep!) узле
должны быть единицами или двойками. Конструктор ноль-\lstinline!Zero!
используется только в пустом списке \lstinline!Shallow Zero!.

Подобным образом, задержав список пар в каждом глубоком узле, мы можем
заставить либо \lstinline!cons!, либо \lstinline!tail! работать за
амортизированное время $O(1)$, а вторую из этих операций за
амортизированное время $O(\log n)$.
\begin{lstlisting}
  datatype $\alpha$ RList = 
         Shallow of $\alpha$ Digit
       | Deep of $\alpha$ Digit $\times$ ($\alpha$ $\times$ $\alpha$) RList susp
\end{lstlisting}
Позволив выбирать из трёх ненулевых цифр в каждом глубоком узле, мы
можем заставить все три функции \lstinline!cons!, \lstinline!head! и
\lstinline!tail! работать за время $O(1)$.
\begin{lstlisting}
  datatype $\alpha$ Digit =
       Zero | One of $\alpha$ | Two of $\alpha$ $\times$ $\alpha$ | Three of $\alpha$ $\times$ $\alpha$ $\times$ $\alpha$
\end{lstlisting}
Как и прежде, конструктор \lstinline!Zero! используется только в
пустом списке.

Чтобы расширить эту схему для поддержки очередей и деков, достаточно
добавить вторую цифру в каждый глубокий узел-\lstinline!Deep!.
\begin{lstlisting}
  datatype $\alpha$ Queue =
         Shallow of $\alpha$ Digit
       | Deep of $\alpha$ Digit $\times$ ($\alpha$ $\times$ $\alpha$) Queue susp $\times$ $\alpha$ Digit
\end{lstlisting}
Первая цифра представляет первые несколько элементов очереди, а
вторая~--- последние несколько элементов. Оставшиеся элементы хранятся
в задержанной очереди пар, которую мы называем \term{срединной
  очередью}{middle queue}.

Выбор типа цифры зависит от того, какие функции мы хотим поддерживать
на каждом конце очереди. В следующей таблице приведены разрешенные
значения для головной цифры очереди, поддерживающей каждое данное
сочетание функций.
$$
\begin{array}{c|c}
  \mbox{поддерживаемые функции} & \mbox{разрешённые цифры} \\
  \hline
  \lstinline!cons! & \lstinline!Zero!, \lstinline!One! \\
  \lstinline!cons/head! & \lstinline!One!, \lstinline!Two! \\
  \lstinline!head/tail! & \lstinline!One!, \lstinline!Two! \\
  \lstinline!cons/head/tail! & \lstinline!One!, \lstinline!Two!, \lstinline!Three! \\
\end{array}
$$
Те же правила выбора относятся и к хвостовой цифре.

В качестве конкретного примера давайте разработаем реализацию
очередей, поддерживающую \lstinline!snoc! на хвостовом конце и
\lstinline!head! и \lstinline!tail! на головном (т.~е., обыкновенных
очередей-FIFO). Обратившись к таблице, мы решаем, что головная цифра
глубокого узла может быть единица-\lstinline!One! или
двойка-\lstinline!Two!, а хвостовая цифра может быть
ноль-\lstinline!Zero! или единица-\lstinline!One!. Цифра в мелком узле
может быть \lstinline!Zero! или \lstinline!One!.

Чтобы добавить к глубокой очереди новый элемент \lstinline!y! через
\lstinline!snoc!, мы смотрим на хвостовую цифру. Если это ноль
(\lstinline!Zero!), мы заменяем хвостовую цифру на 
единицу-\lstinline!One y!. Если это \lstinline!One x!, то мы заменяем её на \lstinline!Zero!
и добавляем пару \lstinline!(x, y)! к срединной очереди. Кроме того,
требуется выписать несколько особых случаев для добавления элементов к
мелкой очереди.
\begin{lstlisting}
  fun snoc (Shallow Zero, y) = Shallow (One y)
    | snoc (Shallow (One x), y) = Deep (Two (x, y), $\$$empty, Zero)
    | snoc (Deep (f, m, Zero), y) = Deep (f, m, One y)
    | snoc (Deep (f, m, One x), y) = 
        Deep (f, $\$$snoc (force m, (x, y)), Zero)
\end{lstlisting}

Чтобы удалить элемент из глубокой очереди через
\lstinline!tail!, мы смотрим на головную цифру. Если это
\lstinline!Two (x, y)!, мы отбрасываем \lstinline!x! и устанавливаем
головную цифру в \lstinline!One y!. Если это \lstinline!One x!, мы
<<занимаем>> в срединной очереди пару \lstinline!(y, z)! и
устанавливаем головную цифру в \lstinline!Two (y, z)!. Опять же, нужно
ещё несколько особых случаев, работающих с мелкими очередями.
\begin{lstlisting}
  fun tail (Shallow (One x)) = empty
    | tail (Deep (Two (x, y), m, r)) = Deep (One y, m, r)
    | tail (Deep (One x, $\$$q, r)) =
        if isEmpty q then Shallow r
        else let val (y, z) = head q
             in Deep (Two (y, z), $\$$tail q, r) end
\end{lstlisting}
Заметим, что в последнем варианте \lstinline!tail! мы вынуждаем
срединную очередь. Полный код приведен на Рис.~\ref{fig:11.1}.

\begin{figure}
  \centering
  
  \caption{Очереди на основе неявного рекурсивного замедления.}
  \label{fig:11.1}
\end{figure}

Теперь мы хотим показать, что \lstinline!snoc! и \lstinline!tail!
работают за амортизированное время $O(1)$. Заметим, что
\lstinline!snoc! никак не обращается к головной цифре, а
\lstinline!tail!~--- к хвостовой цифре. Если мы рассматриваем каждую
из функций по отдельности, то \lstinline!snoc! оказывается аналогичен
функции \lstinline!inc! для ленивых двоичных чисел, а \lstinline!tail!
оказывается аналогичен функции \lstinline!dec! для безнулевых ленивых
двоичных чисел. Модифицируя доказательства для \lstinline!inc! и
\lstinline!dec!, мы легко можем показать, что \lstinline!snoc! и
\lstinline!tail! работают за амортизированное время $O(1)$, если
каждая из них используется отдельно от другой.

Основная идея неявного рекурсивного замедления состоит в том, что
когда функции вроде \lstinline!snoc! и \lstinline!tail! \emph{почти}
независимы друг от друга, мы можем сочетать их доказательства, просто
сложив долги, используемые в каждом из доказательств. Доказательство
для \lstinline!snoc! использует одну единицу долга, если хвостовая
цифра равна \lstinline!Zero! и ноль единиц, еси хвостовая цифра равна
\lstinline!One!. Доказательство для \lstinline!tail! использует одну
единицу долга, если головная цифра равна \lstinline!Two! и ноль
единиц, если головная цифра равна \lstinline!One!. Нижеследующее
доказательство сочетает эти два понятия долга.

\begin{theorem}\label{th:11.1}
  Функции \lstinline!snoc! и \lstinline!tail! работают за
  амортизированное время $O(1)$.

  \noindent
  \emph{Доказательство.} Мы анализируем реализацию очередей, используя
  метод банкира. Долг присваивается каждой задержке; задержки у нас
  всегда находятся в среднем поле какой-либо глубокой очереди.  Мы
  принимаем инвариант долга, позволяющий каждой задержке иметь размер
  долга, зависящий от цифр в головном и хвостовом поле. Среднее поле
  глубокой очереди может иметь до $|f| - |r|$ единиц долга, где $|f|$
  равно одному или двум, а $|r|$ равно нулю или одному.

  Нераздельная стоимость каждой из функций равна $O(1)$, так что нам
  остаётся показать, что ни одна из функций не высвобождает больше,
  чем $O(1)$ единиц долга. Мы приводим только доказательство для
  \lstinline!tail!. Доказательство для \lstinline!snoc! немного проще.

  Мы проводим рассуждения методом передачи долга, который
  близкородствен методу наследования долга.  Каждый раз, когда
  вложенная задержка получает больше долга, чем ей разрешено иметь, мы
  передаем этот долг объемлющей задержке, которая служит средним полем
  предыдущего узла \lstinline!Deep!. Передача долга является
  безопасной операцией, поскольку объемлющая задержка всегда
  вынуждается раньше вложенной.  Передача ответственности за
  высвобождение долга от вложенной задержки к объемлющей гарантирует,
  что этот долг будет высвобожден прежде, чем будет вынуждена
  объемлющая задержка, а следовательно, и раньше, чем может быть вынуждена
  внутренняя. 

  Мы показываем, что каждый вызов \lstinline!tail! передает одну
  единицу долга в объемлющую задержку, кроме самого внешнего вызова, у
  которого объемлющей задержки нет. Этот вызов просто высвобождает
  лишний долг.

  Каждый каскад вызовов \lstinline!tail! заканчивается на вызове
  \lstinline!tail!, заменяющем \lstinline!Two! на
  \lstinline!One!. (Для простоты описания, мы сейчас не учитываем
  возможность добраться до мелкой очереди.) Это уменьшает разрешённый
  размер долга для \lstinline!m! на один, так что мы передаём эту
  лишнюю единицу в объемлющую задержку.

  Всякий промежуточный вызов \lstinline!tail! заменяет \lstinline!f! с
  единицы-\lstinline!One! на двойку-\lstinline!Two! и вызывает
  \lstinline!tail! рекурсивно. Есть два подслучая:
  \begin{itemize}
  \item \lstinline!r! равно \lstinline!Zero!. Очередь \lstinline!m! имеет одну
    единицу долга, и эту единицу требуется высвободить, прежде чем мы можем
    вынудить \lstinline!m!. Мы передаём эту единицу в объемлющую
    задержку. Кроме того, создаём единицу долга, чтобы покрыть
    нераздельную стоимость рекурсивного вызова.  Кроме того, нашей
    задержке передаётся одна единицы долга из рекурсивного вызова.
    Поскольку нашей задержке разрешено иметь до двух единиц долга,
    баланс оказывается в порядке.
  \item \lstinline!r! равно \lstinline!One!. Очередь \lstinline!m! не
    имеет долга, так что мы бесплатно можем её вынудить. Создаём одну
    единицу долга, чтобы покрыть нераздельную стоимость рекурсивного
    вызова. Кроме того, из рекурсивного вызова нам передаётся ещё одна
    единица долга. Поскольку разрешённый размер долга для текущей
    задержки равен одному, мы одну единицу долга оставляем у себя, а
    другую передаём в объемлющую задержку.
  \end{itemize}
\end{theorem}

\begin{exercise}\label{ex:11.1}
  Реализуйте для этих очередей функции \lstinline!lookup! и
  \lstinline!update!. Эти функции должны работать за амортизированное
  время $O(\log i)$. Может быть полезно снабдить каждую очередь
  полем, содержащим её размер.
\end{exercise}

\begin{exercise}\label{ex:11.2}
  С помощью методик, описанных в этом разделе, реализуйте двусторонние
  очереди.
\end{exercise}

\section{Двусторонние очереди с конкатенацией}
\label{sc:11.2}

Наконец, мы реализуем с помощью неявного рекурсивного замедления
двусторонние очереди с конкатенацией, чья сигнатура приведена на
Рис.~\ref{sc:11.2}. Сначала мы описываем относительно простую
реализацию, поддерживающую $\concat$ за амортизированное время $O(\log
n)$, а остальные операции за амортизированное время $O(1)$. Затем мы
строим намного более сложную реализацию, которая улучшает время работы
$\concat$ до $O(1)$.

\begin{figure}
  \centering
  
  (*\mbox{ Возбуждает }Empty\mbox{, если дек пуст }*)\\
  (*\mbox{ Возбуждает }Empty\mbox{, если дек пуст }*)\\
  (*\mbox{ Возбуждает }Empty\mbox{, если дек пуст }*)\\
  (*\mbox{ Возбуждает }Empty\mbox{, если дек пуст }*)\\
  
  \caption{Сигнатура для двусторонних очередей с конкатенацией.}
  \label{fig:11.2}
\end{figure}

Рассмотрим следующую реализацию двусторонних очередей с конкатенацией,
или c-деков. C-дек является либо \term{мелким}{shallow}, либо
\term{глубоким}{deep}. Мелкий c-дек~--- это просто обыкновенный дек,
например, дек по методу банкира из Раздела~\ref{sc:8.4.2}. Глубокий
c-дек состоит из трёх частей: \term{front}{голова},
\term{середина}{middle} и \term{хвост}{rear}. Голова и хвост являются
обыкновенными деками, содержащими не меньше двух элементов
каждый. Середина является c-деком с обыкновенными деками в качестве
элементов, каждый из которых не короче двух. Мы предполагаем, что есть
реализация \lstinline!D!, реализующая сигнатуру \lstinline!Deque!, и
все её функции работают за время $O(1)$ (амортизированное или
жёсткое).
\begin{lstlisting}
  datatype $\alpha$ Cat =
         Shallow of $\alpha$ D.Queue
       | Deep of $\alpha$ D.Queue $\times$ $\alpha$ D.Deque Cat susp $\times$ $\alpha$ D.Queue
\end{lstlisting}
Заметим, что это определение предполагает полиморфную рекурсию.

Чтобы добавить элемент к какому-либо концу, мы просто добавляем его в
головной или хвостовой дек. Например, \lstinline!cons! реализован как
\begin{lstlisting}
  fun cons (x, Shallow d) = Shallow (D.cons (x, d))
    | cons (x, Deep (f, m, r)) = Deep (D.cons (x, f), m, r)
\end{lstlisting}
Чтобы уничтожить элемент на каком-либо конце, мы уничтожаем элемент из
головного либо хвостового дека. Если при этом длина этого дека падает
ниже двух, мы извлекаем следующий дек из середины и делаем его новой
головой либо хвостом. С добавлением остающегося элемента из старого
дека новый дек содержит по крайней мере три элемента. Например, код
\lstinline!tail! выглядит как
\begin{lstlisting}
  fun tail (Shallow d) = Shallow (D.tail d)
    | tail (Deep (f, m, r) =
        let f' = D.tail f
        in
           if not (tooSmall f') then Deep (f', m, r)
           else if isEmpty (force m) then Shallow (dappendL (f', r))
           else Deep (dappendL (f', head (force m)), $\$$tail (force m), r)
        end
\end{lstlisting}
где функция \lstinline!tooSmall! возвращает истину, если длина дека
меньше двух, а \lstinline!dappendL! добавляет дек длины один или два к
деку произвольной длины.

Заметим, что вызовы \lstinline!tail! распространяются на следующий
уровень c-дека только в том случае, когда длина головного дека равна
двум. В терминах из Раздела~\ref{sc:9.2.3} мы можем сказать, что дек
длиной три или более \term{безопасен}{safe}, а дек длиной два
\term{опасен}{dangerous}.  Каждый раз, когда \lstinline!tail!
рекурсивно себя вызывает на следующем уровне, он переводит головной
дек из опасного состояния в безопасное, так что ни на каком уровне
c-дека два последовательных вызова \lstinline!tail! не могут
распространиться на следующий уровень. Мы легко можем доказать, что
\lstinline!tail! работает за амортизированное время $O(1)$, позволив
безопасному деку иметь одну единицу долга, а опасному ноль.

\begin{exercise}\label{ex:11.3}
  Докажите, что \lstinline!tail! и \lstinline!init! вместе работают за
  амортизированное время $O(1)$, сочетая их правила накопления долга
  согласно методике неявного рекурсивного замедления.
\end{exercise}

Как реализовать конкатенацию? Чтобы сконкатенировать два глубоких
c-дека \lstinline!c$_1$! и \lstinline!c$_2$!, мы сохраняем голову
\lstinline!c$_1$! как новую голову, хвост \lstinline!c$_2$! как новый
хвост, а из оставшихся элементов собираем новую середину: хвост
\lstinline!c$_1$! вставляем в середину \lstinline!c$_1$!, голову
\lstinline!c$_2$! в середину \lstinline!c$_2$!, а затем конкатенируем
результаты.
\begin{lstlisting}
  fun (Deep (f$_1$, m$_1$, r$_1$)) $\concat$ (Deep (f$_2$, m$_2$, r$_2$)) =
        Deep (f$_1$, $\$$(snoc (force m$_1$, r$_1$) $\concat$ cons (f$_2$, force m$_2$)), r$_2$)
\end{lstlisting}
(Разумеется, есть ещё варианты, когда \lstinline!c$_1$! или
\lstinline!c$_2$! являются мелкими.) Заметим, что глубина рекурсии
$\concat$ равна глубине более мелкого c-дека. Кроме того, $\concat$
создаёт $O(1)$ долга на каждом уровне, и весь этот долг нужно
немедленно высвободить, чтобы восстановить инвариант долга для
\lstinline!tail! и \lstinline!init!. Следовательно, время работы
$\concat$ равно $O(\min (\log n_1, \log n_2))$, где $n_i$~--- длина
\lstinline!c$_i$!. 

Полный код этой реализации c-деков приведён на Рис.~\ref{fig:11.3}

\begin{figure}
  \centering
  (* $\mbox{предполагает полиморфную рекурсию!}$ *)  \\
  \mbox{\ldots{} \lstinline!snoc!, \lstinline!last! и \lstinline!init!
    определяются симметричным образом \ldots}\\
  
  \caption{Простые деки с конкатенацией.}
  \label{fig:11.3}
\end{figure}

Чтобы улучшить время работы $\concat$ до $O(1)$, мы изменяем
представление c-деков так, чтобы операция $\concat$ не вызывала сама
себя рекурсивно. Основная идея состоит в том, чтобы $\concat$ каждого уровня
обращалась на следующем уровне только к \lstinline!cons! и
\lstinline!snoc!. Вместо трёх сегментов мы теперь заставляем глубокие
c-деки содержать пять сегментов: $(f, a, m, b, r)$. $f$, $m$ и $r$
представляют собой обыкновенные деки: $f$ и $r$ содержат при этом не
менее трёх элементов каждый, а $m$ не менее двух элементов. $a$ и $b$
представляют собой c-деки \term{составных элементов}{compound
  elements}. Вырожденный составной элемент является обыкновенным деком,
содержащим не менее двух элементов.  Полный составной элемент содержит
три сегмента: $(f, c, r)$, где $f$ и $r$~--- обыкновенные деки,
содержащие не меньше чем по два элемента каждый, а $m$~--- c-дек
составных элементов. Этот тип данных может быть записан на Стандартном
ML (с полиморфной рекурсией) так:
\begin{lstlisting}
  datatype $\alpha$ Cat =
         Shallow of $\alpha$ D.Queue
       | Deep of $\alpha$ D.Queue                      (* $\ge 3$ *)
                 $\times$ $\alpha$ CmpdElem Cat susp
                 $\times$ $\alpha$ D.Queue                     (* $\ge 2$ *)
                 $\times$ $\alpha$ CmpdElem Cat susp
                 $\times$ $\alpha$ D.Queue                     (* $\ge 3$ *)
  and $\alpha$ CmpdElem = 
              Simple of $\alpha$ D.Queue               (* $\ge 2$ *)
            | Cmpd of $\alpha$ D.Queue                 (* $\ge 2$ *)
                      $\times$ $\alpha$ CmpdElem Cat susp
                      $\times$ $\alpha$ D.Queue                (* $\ge 2$ *)
\end{lstlisting}
Если нам даны глубокие c-деки 
\lstinline!c$_1$ = Deep (f$_1$, a$_1$, m$_1$, b$_1$, r$_1$)! и 
\lstinline!c$_2$ = Deep (f$_2$, a$_2$, m$_2$, b$_2$, r$_2$)!, их
конкатенация вычисляется следующим образом: прежде всего,
\lstinline!f$_1$! сохраняется как голова результата, а
\lstinline!r$_2$! как хвост результата. Затем, мы строим новый
срединный дек из последнего элемента \lstinline!r$_1$! и первого
элемента \lstinline!f$_2$!.  Затем мы порождаем составной элемент из
\lstinline!m$_1$!, \lstinline!b$_1$! и остатка \lstinline!r$_1$!, и
прицепляем его к концу \lstinline!a$_1$! через \lstinline!snoc!. Это
будет сегмент \lstinline!a! результата. Наконец, мы порождаем
составной элемент из остатка \lstinline!f$_2$!, \lstinline!a$_2$! и
\lstinline!m$_2$!, и присоединяем его к началу \lstinline!b$_2$!. Это
будет сегмент \lstinline!b! результата. Вся реализация выглядит как
\begin{lstlisting}
  fun (Deep (f$_1$, a$_1$, m$_1$, b$_1$, r$_1$)) $\concat$ (Deep (f$_2$, a$_2$, m$_2$, b$_2$, r$_2$)) =
        let val (r$'_1$, m, f$'_2$) = share (r$_1$, f$_2$)
            val a$'_1$ - $\$$snoc (force a$_1$, Cmpd (m$_1$, b$_1$, r$'_1$))
            val b$'_2$ = $\$$cons (Cmpd (f$'_2$, a$_2$, m$_2$), force b$_2$)
        in Deep (f$_1$, a$'_1$, m, b$'_2$, r$_2$) end
\end{lstlisting}
где
\begin{lstlisting}
  fun share (f, r) =
        let val m = D.cons (D.last f, D.cons (D.head r, D.empty))
        in (D.init f, m, D.tail r)
  fun cons (x, Deep (f, a, m, b, r)) = Deep (D.cons (x, f), a, m, b, r)
  fun snoc (Deep (f, a, m, b, r), x) = Deep (f, a, m, b, D.snoc (r, x))
\end{lstlisting}
(Ради простоты описания мы опускаем варианты с участием мелких
c-деков.)

К сожалению, \lstinline!tail! и \lstinline!init! в этой реализации
устроены весьма коряво. Поскольку эти две функции симметричны, мы
описываем только \lstinline!tail!. Если у нас есть c-дек
\lstinline!Deep (f, a, m, b, r)!, возможны шесть вариантов:
\begin{itemize}
\item $|\lstinline!f!| > 3$
\item $|\lstinline!f!| = 3$
  \begin{itemize}
  \item \lstinline!a! непуст.
    \begin{itemize}
    \item Первый составной элемент \lstinline!a! вырожден.
    \item Первый составной элемент \lstinline!a! невырожден.
    \end{itemize}
  \item \lstinline!a! пуст, а \lstinline!b! непуст.
    \begin{itemize}
    \item Первый составной элемент \lstinline!b! вырожден.
    \item Первый составной элемент \lstinline!b! невырожден.
    \end{itemize}
  \item \lstinline!a! и \lstinline!b! оба пусты.
  \end{itemize}
\end{itemize}
Мы описываем поведение \lstinline!tail c! в первых трёх случаях.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "pfds"
%%% End: 
